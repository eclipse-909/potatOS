/* --------
   Utils.ts

   Utility functions.
   -------- */

module TSOS {
	export class Utils {
		public static rot13(str: string): string {
			/*
			   This is an easy-to understand implementation of the famous and common Rot13 obfuscator.
			   You can do this in three lines with a complex regular expression, but I'd have
			   trouble explaining it in the future.  There's a lot to be said for obvious code.
			*/
			let retVal: string = "";
			for (const i in <any>str) {    // We need to cast the string to any for use in the for...in construct.
				const ch: string = str[i];
				let code: number = 0;
				if ("abcedfghijklmABCDEFGHIJKLM".indexOf(ch) >= 0) {
					code = str.charCodeAt(Number(i)) + 13;  // It's okay to use 13.  It's not a magic number, it's called rot13.
					retVal = retVal + String.fromCharCode(code);
				} else if ("nopqrstuvwxyzNOPQRSTUVWXYZ".indexOf(ch) >= 0) {
					code = str.charCodeAt(Number(i)) - 13;  // It's okay to use 13.  See above.
					retVal = retVal + String.fromCharCode(code);
				} else {
					retVal = retVal + ch;
				}
			}
			return retVal;
		}
	}

	//Generated by Chat-GPT
	class BTreeNode {
		// Array of keys (base, limit)
		keys: {base: number, limit: number}[];
		// Array of children nodes
		children: BTreeNode[];
		// True if the node is a leaf
		isLeaf: boolean;
		// Minimum degree
		t: number;

		constructor(t: number, isLeaf: boolean) {
			this.t = t;
			this.isLeaf = isLeaf;
			this.keys = [];
			this.children = [];
		}

		// Search for a key in the subtree rooted with this node
		search(base: number): {base: number, limit: number} | null {
			let i: number = 0;
			while (i < this.keys.length && base > this.keys[i].base) {
				i++;
			}
			if (i < this.keys.length && this.keys[i].base === base) {
				return this.keys[i];
			}
			if (this.isLeaf) {
				return null; // If reached a leaf node and not found
			}
			return this.children[i].search(base); // Recur to the child
		}

		// Insert a new key in the subtree rooted with this node
		insertNonFull(key: {base: number, limit: number}): boolean {
			let i: number = this.keys.length - 1;
			if (this.isLeaf) {
				// Insert the key in the correct position in the leaf node
				while (i >= 0 && key.base < this.keys[i].base) {
					this.keys[i + 1] = this.keys[i];
					i--;
				}
				this.keys[i + 1] = key;
				return true;
			} else {
				// Move down the tree to find the appropriate child
				while (i >= 0 && key.base < this.keys[i].base) {
					i--;
				}
				i++;
				// Check if the next node exists and validate the limit
				if (i < this.keys.length && key.limit >= this.keys[i].base) {
					return false; // Limit condition not met, do not insert
				}
				if (this.children[i].keys.length === 2 * this.t - 1) {
					// If the child is full, split it
					this.splitChild(i, this.children[i]);
					// After splitting, decide which of the two children to insert into
					if (key.base > this.keys[i].base) {
						i++;
					}
				}
				return this.children[i].insertNonFull(key);
			}
		}

		// Split the child y of this node. 'i' is the index of y in the child array.
		splitChild(i: number, y: BTreeNode): void {
			const z: BTreeNode = new BTreeNode(this.t, y.isLeaf);
			z.keys = y.keys.slice(this.t, 2 * this.t - 1);
			if (!y.isLeaf) {
				z.children = y.children.slice(this.t, 2 * this.t);
			}
			y.keys = y.keys.slice(0, this.t - 1);
			this.children.splice(i + 1, 0, z);
			this.keys.splice(i, 0, y.keys[this.t - 1]);
		}

		// Remove a key from the subtree rooted with this node
		remove(base: number): void {
			const idx: number = this.findKey(base);
			if (idx < this.keys.length && this.keys[idx].base === base) {
				if (this.isLeaf) {
					this.keys.splice(idx, 1);
				} else {
					this.removeFromNonLeaf(idx);
				}
			} else {
				if (this.isLeaf) {
					console.log("The key does not exist in the tree.");
					return;
				}
				const flag: boolean = (idx === this.keys.length);
				if (this.children[idx].keys.length < this.t) {
					this.fill(idx);
				}
				if (flag && idx > this.keys.length) {
					this.children[idx - 1].remove(base);
				} else {
					this.children[idx].remove(base);
				}
			}
		}

		// Find the first key greater than or equal to base
		findKey(base: number): number {
			let idx: number = 0;
			while (idx < this.keys.length && this.keys[idx].base < base) {
				idx++;
			}
			return idx;
		}

		// Remove the key at idx from a non-leaf node
		removeFromNonLeaf(idx: number): void {
			const key: {base: number, limit: number} = this.keys[idx];
			if (this.children[idx].keys.length >= this.t) {
				const pred: {base: number, limit: number} = this.getPred(idx);
				this.keys[idx] = pred;
				this.children[idx].remove(pred.base);
			} else if (this.children[idx + 1].keys.length >= this.t) {
				const succ: {base: number, limit: number} = this.getSucc(idx);
				this.keys[idx] = succ;
				this.children[idx + 1].remove(succ.base);
			} else {
				this.merge(idx);
				this.children[idx].remove(key.base);
			}
		}

		// Get predecessor of keys[idx]
		getPred(idx: number): {base: number, limit: number} {
			let cur: BTreeNode = this.children[idx];
			while (!cur.isLeaf) {
				cur = cur.children[cur.keys.length];
			}
			return cur.keys[cur.keys.length - 1];
		}

		// Get successor of keys[idx]
		getSucc(idx: number): {base: number, limit: number} {
			let cur: BTreeNode = this.children[idx + 1];
			while (!cur.isLeaf) {
				cur = cur.children[0];
			}
			return cur.keys[0];
		}

		// Fill the child[idx] if it has less than t-1 keys
		fill(idx: number): void {
			if (idx !== 0 && this.children[idx - 1].keys.length >= this.t) {
				this.borrowFromPrev(idx);
			} else if (idx !== this.keys.length && this.children[idx + 1].keys.length >= this.t) {
				this.borrowFromNext(idx);
			} else {
				if (idx !== this.keys.length) {
					this.merge(idx);
				} else {
					this.merge(idx - 1);
				}
			}
		}

		// Borrow a key from children[idx-1]
		borrowFromPrev(idx: number): void {
			const child: BTreeNode = this.children[idx];
			const sibling: BTreeNode = this.children[idx - 1];
			child.keys.unshift(this.keys[idx - 1]);
			if (!child.isLeaf) {
				child.children.unshift(sibling.children.pop()!);
			}
			this.keys[idx - 1] = sibling.keys.pop()!;
		}

		// Borrow a key from children[idx+1]
		borrowFromNext(idx: number): void {
			const child: BTreeNode = this.children[idx];
			const sibling: BTreeNode = this.children[idx + 1];
			child.keys.push(this.keys[idx]);
			if (!child.isLeaf) {
				child.children.push(sibling.children.shift()!);
			}
			this.keys[idx] = sibling.keys.shift()!;
		}

		// Merge children[idx] and children[idx+1]
		merge(idx: number): void {
			const child: BTreeNode = this.children[idx];
			const sibling: BTreeNode = this.children[idx + 1];
			child.keys.push(this.keys[idx]);
			child.keys = child.keys.concat(sibling.keys);
			if (!child.isLeaf) {
				child.children = child.children.concat(sibling.children);
			}
			this.keys.splice(idx, 1);
			this.children.splice(idx + 1, 1);
		}
	}

	//Generated by Chat-GPT
	export class BTree {
		private root: BTreeNode | null;
		private t: number; // Minimum degree

		public constructor(t: number) {
			this.root = null;
			this.t = t;
		}

		// Search for a key in the tree
		public search(base: number): {base: number, limit: number} | null {
			if (this.root === null) {
				return null;
			}
			return this.root.search(base);
		}

		// Insert a new key in the B-tree
		public insert(key: {base: number, limit: number}): boolean {
			// If the tree is empty, create a new root node with the key
			if (this.root === null) {
				this.root = new BTreeNode(this.t, true);
				this.root.keys.push(key);
				return true; // Insertion was successful
			} else {
				// If the root is full, split it and create a new root
				if (this.root.keys.length === 2 * this.t - 1) {
					const s = new BTreeNode(this.t, false);
					s.children.push(this.root);
					s.splitChild(0, this.root);
					// Decide which child to insert into
					let i: number = 0;
					if (s.keys[0].base < key.base) {
						i++;
					}
					// Check if the insertion is valid
					if (i < s.keys.length && key.limit >= s.keys[i].base) {
						return false; // Insertion failed due to limit condition
					}
					// Insert the key into the appropriate child
					return s.children[i].insertNonFull(key); // Return the result of the recursive insert
				} else {
					// Insert the key into the non-full root
					if (this.root.keys.length < 2 * this.t - 1) {
						// Check if the insertion is valid
						let i: number = 0;
						while (i < this.root.keys.length && key.base > this.root.keys[i].base) {
							i++;
						}
						if (i < this.root.keys.length && key.limit >= this.root.keys[i].base) {
							return false; // Insertion failed due to limit condition
						}
						return this.root.insertNonFull(key); // Return the result of the recursive insert
					} else {
						// If the root is not full, just insert
						return this.root.insertNonFull(key); // Return the result of the recursive insert
					}
				}
			}
		}

		// Remove a key from the B-tree
		public remove(base: number): void {
			if (this.root === null) {
				console.log("The tree is empty.");
				return;
			}
			this.root.remove(base);
			if (this.root.keys.length === 0) {
				if (this.root.isLeaf) {
					this.root = null;
				} else {
					this.root = this.root.children[0];
				}
			}
		}
	}
}